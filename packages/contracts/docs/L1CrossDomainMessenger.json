{
    "methods": {
        "allowMessage": {
            "stateMutability": "nonpayable",
            "code": "function allowMessage(bytes32 _xDomainCalldataHash) external nonpayable",
            "inputs": {
                "_xDomainCalldataHash": {
                    "type": "bytes32",
                    "description": "Hash of the message to block."
                }
            },
            "outputs": {},
            "notice": "Allow a message."
        },
        "blockMessage": {
            "stateMutability": "nonpayable",
            "code": "function blockMessage(bytes32 _xDomainCalldataHash) external nonpayable",
            "inputs": {
                "_xDomainCalldataHash": {
                    "type": "bytes32",
                    "description": "Hash of the message to block."
                }
            },
            "outputs": {},
            "notice": "Block a message."
        },
        "blockedMessages": {
            "stateMutability": "view",
            "code": "function blockedMessages(bytes32) external view returns (bool)",
            "inputs": {
                "_0": {
                    "type": "bytes32"
                }
            },
            "outputs": {
                "_0": {
                    "type": "bool"
                }
            }
        },
        "initialize": {
            "stateMutability": "nonpayable",
            "code": "function initialize(address _libAddressManager) external nonpayable",
            "inputs": {
                "_libAddressManager": {
                    "type": "address",
                    "description": "Address of the Address Manager."
                }
            },
            "outputs": {}
        },
        "libAddressManager": {
            "stateMutability": "view",
            "code": "function libAddressManager() external view returns (contract Lib_AddressManager)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "contract Lib_AddressManager"
                }
            }
        },
        "owner": {
            "stateMutability": "view",
            "code": "function owner() external view returns (address)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "address"
                }
            },
            "details": "Returns the address of the current owner."
        },
        "pause": {
            "stateMutability": "nonpayable",
            "code": "function pause() external nonpayable",
            "inputs": {},
            "outputs": {},
            "notice": "Pause relaying."
        },
        "paused": {
            "stateMutability": "view",
            "code": "function paused() external view returns (bool)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "bool"
                }
            },
            "details": "Returns true if the contract is paused, and false otherwise."
        },
        "relayMessage": {
            "stateMutability": "nonpayable",
            "code": "function relayMessage(address _target, address _sender, bytes _message, uint256 _messageNonce, IL1CrossDomainMessenger.L2MessageInclusionProof _proof) external nonpayable",
            "inputs": {
                "_target": {
                    "type": "address",
                    "description": "Target contract address."
                },
                "_sender": {
                    "type": "address",
                    "description": "Message sender address."
                },
                "_message": {
                    "type": "bytes",
                    "description": "Message to send to the target."
                },
                "_messageNonce": {
                    "type": "uint256",
                    "description": "Nonce for the provided message."
                },
                "_proof": {
                    "type": "IL1CrossDomainMessenger.L2MessageInclusionProof",
                    "description": "Inclusion proof for the given message."
                }
            },
            "outputs": {},
            "notice": "Relays a cross domain message to a contract."
        },
        "relayedMessages": {
            "stateMutability": "view",
            "code": "function relayedMessages(bytes32) external view returns (bool)",
            "inputs": {
                "_0": {
                    "type": "bytes32"
                }
            },
            "outputs": {
                "_0": {
                    "type": "bool"
                }
            }
        },
        "renounceOwnership": {
            "stateMutability": "nonpayable",
            "code": "function renounceOwnership() external nonpayable",
            "inputs": {},
            "outputs": {},
            "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
        },
        "replayMessage": {
            "stateMutability": "nonpayable",
            "code": "function replayMessage(address _target, address _sender, bytes _message, uint256 _queueIndex, uint32 _oldGasLimit, uint32 _newGasLimit) external nonpayable",
            "inputs": {
                "_target": {
                    "type": "address",
                    "description": "Target contract address."
                },
                "_sender": {
                    "type": "address",
                    "description": "Original sender address."
                },
                "_message": {
                    "type": "bytes",
                    "description": "Message to send to the target."
                },
                "_queueIndex": {
                    "type": "uint256",
                    "description": "CTC Queue index for the message to replay."
                },
                "_oldGasLimit": {
                    "type": "uint32",
                    "description": "Original gas limit used to send the message."
                },
                "_newGasLimit": {
                    "type": "uint32",
                    "description": "New gas limit to be used for this message."
                }
            },
            "outputs": {},
            "notice": "Replays a cross domain message to the target messenger."
        },
        "resolve": {
            "stateMutability": "view",
            "code": "function resolve(string _name) external view returns (address)",
            "inputs": {
                "_name": {
                    "type": "string",
                    "description": "Name to resolve an address for."
                }
            },
            "outputs": {
                "_0": {
                    "type": "address",
                    "description": "Address associated with the given name."
                }
            },
            "notice": "Resolves the address associated with a given name."
        },
        "sendMessage": {
            "stateMutability": "nonpayable",
            "code": "function sendMessage(address _target, bytes _message, uint32 _gasLimit) external nonpayable",
            "inputs": {
                "_target": {
                    "type": "address",
                    "description": "Target contract address."
                },
                "_message": {
                    "type": "bytes",
                    "description": "Message to send to the target."
                },
                "_gasLimit": {
                    "type": "uint32",
                    "description": "Gas limit for the provided message."
                }
            },
            "outputs": {},
            "notice": "Sends a cross domain message to the target messenger."
        },
        "successfulMessages": {
            "stateMutability": "view",
            "code": "function successfulMessages(bytes32) external view returns (bool)",
            "inputs": {
                "_0": {
                    "type": "bytes32"
                }
            },
            "outputs": {
                "_0": {
                    "type": "bool"
                }
            }
        },
        "transferOwnership": {
            "stateMutability": "nonpayable",
            "code": "function transferOwnership(address newOwner) external nonpayable",
            "inputs": {
                "newOwner": {
                    "type": "address"
                }
            },
            "outputs": {},
            "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
        },
        "xDomainMessageSender": {
            "stateMutability": "view",
            "code": "function xDomainMessageSender() external view returns (address)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "address"
                }
            }
        }
    },
    "events": {
        "FailedRelayedMessage": {
            "code": "event FailedRelayedMessage(bytes32 indexed msgHash)",
            "inputs": {
                "msgHash": {
                    "type": "bytes32",
                    "indexed": true
                }
            }
        },
        "MessageAllowed": {
            "code": "event MessageAllowed(bytes32 indexed _xDomainCalldataHash)",
            "inputs": {
                "_xDomainCalldataHash": {
                    "type": "bytes32",
                    "indexed": true
                }
            }
        },
        "MessageBlocked": {
            "code": "event MessageBlocked(bytes32 indexed _xDomainCalldataHash)",
            "inputs": {
                "_xDomainCalldataHash": {
                    "type": "bytes32",
                    "indexed": true
                }
            }
        },
        "OwnershipTransferred": {
            "code": "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)",
            "inputs": {
                "previousOwner": {
                    "type": "address",
                    "indexed": true
                },
                "newOwner": {
                    "type": "address",
                    "indexed": true
                }
            }
        },
        "Paused": {
            "code": "event Paused(address account)",
            "inputs": {
                "account": {
                    "type": "address",
                    "indexed": false
                }
            }
        },
        "RelayedMessage": {
            "code": "event RelayedMessage(bytes32 indexed msgHash)",
            "inputs": {
                "msgHash": {
                    "type": "bytes32",
                    "indexed": true
                }
            }
        },
        "SentMessage": {
            "code": "event SentMessage(address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit)",
            "inputs": {
                "target": {
                    "type": "address",
                    "indexed": true
                },
                "sender": {
                    "type": "address",
                    "indexed": false
                },
                "message": {
                    "type": "bytes",
                    "indexed": false
                },
                "messageNonce": {
                    "type": "uint256",
                    "indexed": false
                },
                "gasLimit": {
                    "type": "uint256",
                    "indexed": false
                }
            }
        },
        "Unpaused": {
            "code": "event Unpaused(address account)",
            "inputs": {
                "account": {
                    "type": "address",
                    "indexed": false
                }
            }
        }
    },
    "errors": {},
    "title": "L1CrossDomainMessenger",
    "details": "The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages from L2 onto L1. In the event that a message sent from L1 to L2 is rejected for exceeding the L2 epoch gas limit, it can be resubmitted via this contract's replay function.",
    "name": "L1CrossDomainMessenger"
}