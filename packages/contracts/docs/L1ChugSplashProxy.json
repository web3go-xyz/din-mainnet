{
    "methods": {
        "getImplementation": {
            "stateMutability": "nonpayable",
            "code": "function getImplementation() external nonpayable returns (address)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "address",
                    "description": "Implementation address."
                }
            },
            "notice": "Queries the implementation address. Can only be called by the owner OR by making an eth_call and setting the \"from\" address to address(0)."
        },
        "getOwner": {
            "stateMutability": "nonpayable",
            "code": "function getOwner() external nonpayable returns (address)",
            "inputs": {},
            "outputs": {
                "_0": {
                    "type": "address",
                    "description": "Owner address."
                }
            },
            "notice": "Queries the owner of the proxy contract. Can only be called by the owner OR by making an eth_call and setting the \"from\" address to address(0)."
        },
        "setCode": {
            "stateMutability": "nonpayable",
            "code": "function setCode(bytes _code) external nonpayable",
            "inputs": {
                "_code": {
                    "type": "bytes",
                    "description": "New contract code to run inside this contract."
                }
            },
            "outputs": {},
            "notice": "Sets the code that should be running behind this proxy. Note that this scheme is a bit different from the standard proxy scheme where one would typically deploy the code separately and then set the implementation address. We're doing it this way because it gives us a lot more freedom on the client side. Can only be triggered by the contract owner."
        },
        "setOwner": {
            "stateMutability": "nonpayable",
            "code": "function setOwner(address _owner) external nonpayable",
            "inputs": {
                "_owner": {
                    "type": "address",
                    "description": "New owner of the proxy contract."
                }
            },
            "outputs": {},
            "notice": "Changes the owner of the proxy contract. Only callable by the owner."
        },
        "setStorage": {
            "stateMutability": "nonpayable",
            "code": "function setStorage(bytes32 _key, bytes32 _value) external nonpayable",
            "inputs": {
                "_key": {
                    "type": "bytes32",
                    "description": "Storage key to modify."
                },
                "_value": {
                    "type": "bytes32",
                    "description": "New value for the storage key."
                }
            },
            "outputs": {},
            "notice": "Modifies some storage slot within the proxy contract. Gives us a lot of power to perform upgrades in a more transparent way. Only callable by the owner."
        }
    },
    "events": {},
    "errors": {},
    "title": "L1ChugSplashProxy",
    "details": "Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty! Note for future developers: do NOT make anything in this contract 'public' unless you know what you're doing. Anything public can potentially have a function signature that conflicts with a signature attached to the implementation contract. Public functions SHOULD always have the 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that modifier. And there almost certainly is not a good reason to not have that modifier. Beware!",
    "name": "L1ChugSplashProxy"
}